Strings are immutable.

String methods:- trim(), toUpperCase(), toLowerCase(), slice(start,end)

cloning array
let array1 = ["item1", "item2"];
let array2 = array1.slice(0) or array1.slice(); // 1st way and fastest
let array2 = [].concat(array1); // 2nd way 
let array2 = [...array1]; // 3rd way


for of loop works on array items.
for in loop works on array index.


How to iterate object:-
1. for in loop
2. Object.keys:-Object.keys return array of keys in object.


example:
const person = {name: "ABC", age: 22, "person hobbies": ["guitar", "sleeping", "listening music"]};

1. for in loop:-
for(let key in person) {
	console.log(person[key]);
}

2. Object.keys
for(let key of Object.keys(person)) {
	console.log(person[key]);
}

spread operator on string in array
const arr = [..."abc"];
console.log(arr); // ["a", "b", "c"]

spread operator on string in object
const obj = {..."abc"};
console.log(obj); // {0: "a", 1: "b", 2: "c"}

spread operator on array in object
const obj = {...["item1", "item2"]};
console.log(obj); // {0: "item1", 1: "item2"}

Lexical Scope: Searching for variable in its parent's scope.

Higher Order Function(HOF):- A function, which can receive a function as a parameter or can return a function, is known as HOF.

forEach, map, filter , reduce will not change the original array but sort, fill, splice method will change the original array.

myArr.fill(value,start,end); // return the changed array
myArr.splice(start, num of items to be deleted, inserted items); // return array of deleted items 

Iterables:- those data types on which we can apply for of loop. (String, Array, Map).

Set:- It is a collection of unique values(no duplicate value allowed). A set can hold any value of any data type. No index based access. Order is no guaranteed.
let mySet = new Set();
 
Map:-It is iterable. store data in ordered fashion. Store key value pair (like object) but duplicate keys are not allowed like objects.

difference between map and object:-
Object can only have string or symbol as key but in Map you can use any datatype as key like array, object , number.

let myMap = new Map();
let myMap = new Map([['key1', 'value1'], ['key2', 'value2']]);

Cloning Object:-
const person = {name: "ABC", age: 22, "person hobbies": ["guitar", "sleeping", "listening music"]};
const obj = {...person}; //1 way
const obj = Object.assign({}, person); //2 way

Optional Chaining:- checking that variable is exist or not which is present before question mark if that variable is present then it will proceed.
const obj = {firstName: 'Himanshu', address: {houseNum: 007}};
console.log(obj?.firstName);
console.log(obj?.address?.houseNum);

this inside arrow function:- Inside arrow function this keyword take reference from it's surrounding(one level up).
const user = {
	firstName: "Harsh",
	age: 18,
	about: () => {
		console.log(this, this.firstName, this.age);
	}
}
user.about(); // Window undefined undefined

Factory function:- A function that creates an object and returns it.

Object.create(obj) is creating a blank object and setting the __proto__ of instance to the provided obj. 

new keyword sets [[Prototype]] or __proto__ of instance(object) to Constructor function's prototype property. 

for checking own keys of object we can use hasOwnProperty method.
obj.hasOwnProperty(key) --> boolean value

Object.getPrototypeOf(obj) return the prototype (i.e. the value of the internal [[Prototype]] or __proto__ property) of the specified object. 

Inheritance in JS using extends keyword.
example for class; inheritance(base(parent) class, sub(child) class) extends keyword; super keyword; method overriding; static properties and methods
 
class Animal {
	constructor(name, age) {
		this.name = name;
		this.age = age;
	}
	
	static planet = "Earth";

	static show() {
		return 'This is static method';
	}
	
	eat() {
		return `${this.name} is eating.`;
	}
}

class Dog extends Animal {
	constructor(name, age, speed) {
		super(name, age);
		this.speed = speed;
	}
	
	eat() {
		return `Modified: ${this.name} is eating.`;
	}
}

const tommy = new Dog("tommy", 2, 10);
tommy.eat();
Dog.planet || Animal.planet // accessing static property
Dog.show() || Animal.show() // accessing static method

Static properties and methods cannot be directly accessed on instances of the class. Instead, they're accessed on the class itself. It is also inherited.
Static methods are often utility functions, such as functions to create or clone objects, whereas static properties are useful for caches, fixed-configuration, or any other data you don't need to be replicated across instances.

In JavaScript, there are two kinds of object properties:
Data properties (normal properties)
Accessor properties (getter and setter)

In JavaScript, accessor properties are methods that get or set the value of an object. For that, we use these two keywords:
get - to define a getter method to get the value as a property
set - to define a setter method to set the property value

let user = {
  name: "John",
  surname: "Smith",

  get fullName() {
    return `${this.name} ${this.surname}`;
  },

  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  }
};

// trying to access as a method
console.log(user.fullName()) // error

// accessing getter method
console.log(user.fullName) // John Smith

// set fullName is executed with the given value.
user.fullName = "Alice Cooper";

alert(user.name); // Alice
alert(user.surname); // Cooper


Compilation Phase:-
1. Tokenizing/lexing
2. Parsing
3. Code Generation

code sabse pahle compile hota h jisme sabse pahle tokens bante h fir usko parse krte h jisse Abstract Syntax Tree (AST) banta h uske baad code generate hota h jiske baad code execute hota h.

compile karne k 2 reason h
1. early error checking
2. determining appropriate scope for variables

In order to execute JS code JS creates execution context

Global Execution Context
1. creation phase // Memory creation
2. code execution phase

JavaScript is synchronous programming language and it is singal threaded.

Temporal Dead Zone(TDZ):- jab tak variable uninitialized rahte h wo TDZ m hote h.

arguments:- array like object. index based access and length property.

Note:- Array like object --> indexing, length property

4 ways to add JS file in HTML

1. <head>
		<script src="./app.js"></script>
   </head>
isme HTML parsing se pahle hi javacript file execute hone lagta h aur jisse error aate h kyuki HTML parsing nhi hue hoti hai.


2.<body>
<script src="./app.js"></script>
</body>
jab javascript file last m add krte h to us case m pahle HTML file parse hota h usme time lgta h fir javascript file load hota h usme time lagta h aur fir execute hone m time lagta h.

3.<head>
<script src="./app.js" async></script>
</head>
jab javascript file add krte time async attribute likhte h tab HTML file parsing k saath javascript file bhi load hota rhta h par jaise hi javascript file load ho jata wo HTML parsing ko jha tk parsing kiya h wha tak krk stop kr deta h aur javascript file ko execute krne lagta h Jisse error hone k chances ho jate h.

4.<head>
<script src="./app.js" defer></script>
</head>
jab javascript file add krte time defer attribute likhte h tab HTML file parsing k saath javascript file bhi load hota rhta h aur jab javacript file load ho jata h to ye javascript ki file ko turant execute nhi krta h balki wait krta h jab tk ki HTML parsing complete na ho jaye. fir JS file ko execute krta h.

getElementById() method returns element object.
querySelector() method returns the first element object that matches a CSS selector.
getElementsByClassName() gives HTMLCollections(array like object) on which we can apply for loop, for-of loop.
getElementsByTagName() gives HTMLCollections(array like object) on which we can apply for loop, for-of loop.
querySelectorAll() gives NodeList(array like object) on which we can apply for loop, for-of loop and forEach loop.

textContent gives all the texts even some text part of that element is hidden whereas innerText gives only those text which is visible on webpage.  

getAttribute('attribute') method return the value of provided attribute.
setAttribute('attribute', 'value') method set the value of provided attribute.

Iterate elements:- 
HTMLCollections --> for loop, for-of loop.
NodeList --> for loop, for-of loop and forEach loop.

Note:- Array.from(value) method return array of provided value.

DOM Traversing:-
document.getRootNode(); //document
childNodes --> property gives NodeList of child of the element including text node.
parentNode --> property gives the parent node of the element.
parentElement --> property gives the parent element of the element.
The difference between parentElement and parentNode, is that parentElement returns null if the parent node is not an element node.
nextSibling --> property gives the next sibling node (text node also include). 
nextElementSibling --> property gives the next sibling element (text node not include).
Note:- to show white-space we can apply below style
* {
	white-space: normal // default setting
	white-space: pre // for showing space on webpage
}
children --> property gives the child element of the element.

classList --> The classList property returns (DOMTokenList) the CSS classnames of an element.
			  classList property itself is read-only, you can modify its associated DOMTokenList using the add(), remove(), contains(), replace(), and toggle() methods.
			  
Add new element to page:-
	createElement()
	append() -->method inserts a set of Node objects or string objects after the last child of the Element.
	Differences from Node.appendChild():
		1.	Element.append() allows you to also append string objects, whereas Node.appendChild() only accepts Node objects.
		2.	Element.append() has no return value, whereas Node.appendChild() returns the appended Node object.
		3.	Element.append() can append several nodes and strings, whereas Node.appendChild() can only append one node.
	prepend() --> method inserts a set of Node objects or string objects before the first child of the Element.
	remove() 
	before() --> method inserts a set of Node or string objects in the children list of this Element's parent, just before this Element.
	after() -->  method inserts a set of Node or string objects in the children list of the Element's parent, just after the Element.

elem.insertAdjacentHTML(where, html);
	beforebegin
	afterbegin
	beforeend
	afterend
	
	<!-- beforebegin -->
	<p>
	  <!-- afterbegin -->
	  foo
	  <!-- beforeend -->
	</p>
	<!-- afterend -->


clone Node:- 
elem.cloneNode(true) --> it will clone the elem and for the deep cloning provide true argument.

some old methods to support IE:-
appendChild() -->  method appends a node (element) as the last child of an element.
	element.appendChild(node) 
insertBefore() --> method inserts a child node before an existing child. If the given node already exists in the document, insertBefore() moves it from its current position to the new position.
	element.insertBefore(newChild, existingChild)
replaceChild() --> method replaces a child node with a new node.
	node.replaceChild(newnode, oldnode)
removeChild() --> method removes an element's child.
	element.removeChild(node)

Note:- li{item $}*5

static list & live list:-
querySelectorAll() --> provide static list.
getElementsBySomething() --> provide live list.

get dimension of element:-
elem.getBoundingClientRect() --> returned value is a DOMRect object which is the smallest rectangle which contains the entire element, including its padding and border-width. The left, top, right, bottom, x, y, width, and height properties describe the position and size of the overall rectangle in pixels.

value of 'this' in eventListener callback

1. this with normal function:-
elem.addEventListener('click', function() {
	console.log(this); // elem
})

2. this with arrow function:-
elem.addEventListener('click', () => {
	console.log(this); //window
})

Event Object:-
1. with normal function
elem.addEventListener('click', function(e) {
	console.log(e.target); // elem
	console.log(e.currentTarget); // elem
})

2. with arrow function
elem.addEventListener('click',(e) => {
	console.log(e.target); // elem
	console.log(e.currentTarget); // elem
})

Note:- 
currentTarget--> kis element par eventListener attach hai.  
target--> kis element ne event ko triger kiya.

event bubbling / event propogation  --> target p event aane k baad parent p jata h.
event capturing ---> sabse pahle capturing hota h fir bubbling hota h. capturing ko capture krne k liye true 3rd agrument pass krna hota h eventListener m.
event delegation ---> kisi ek element p eventListener laga kar uske parent ya child p same event k liye kuch bhi perform krana

Note: - h1.heading$*7{Hello world} --> create 7 h1 tag with different class (heading1,..,heading7)

setTimeout(cb,time) ---> clearTimeout(id)
setInterval(cb, time) ---> clearInterval(id)

Promise:- JavaScript Promise are easy to manage when dealing with multiple asynchronous operations where callbacks can create callback hell leading to unmanageable code.
			Promises are used to handle asynchronous operations in JavaScript.
			
Syntax:
let promise = new Promise(function(resolve, reject){
     //do something
});

Parameters:-
1. The promise constructor takes only one argument which is a callback function
2. The callback function takes two arguments, resolve and reject
		a.Perform operations inside the callback function and if everything went well then call resolve.
		b.If desired operations do not go well then call reject.
		
A Promise has four states:
1.fulfilled: Action related to the promise succeeded
2.rejected: Action related to the promise failed
3.pending: Promise is still pending i.e. not fulfilled or rejected yet
4.settled: Promise has been fulfilled or rejected

let promise = new Promise(function (resolve, reject) {
    const x = "geeksforgeeks";
    const y = "geeksforgeeks"
    if (x === y) {
        resolve();
    } else {
        reject();
    }
});
 
promise.
    then(function () {
        console.log('Success, You are a GEEK');
    }).
    catch(function () {
        console.log('Some error has occurred');
    });
	
Promise Consumers: Promises can be consumed by registering functions using .then and .catch methods.

1.Promise then() Method: It is invoked when a promise is either resolved or rejected. It may also be defined as a carrier that takes data from promise and further executes it successfully.

Parameters: It takes two functions as parameters.

The first function is executed if the promise is resolved and a result is received.
The second function is executed if the promise is rejected and an error is received. (It is optional and there is a better way to handle error using .catch() method
Syntax:

.then(function(result){
        //handle success
}, function(error){
        //handle error
})

example:-

let promise = new Promise(function (resolve, reject) {
    resolve('Geeks For Geeks');
})
 
promise
    .then(function (successMessage) {
        //success handler function is invoked
        console.log(successMessage);
    }, function (errorMessage) {
        console.log(errorMessage);
    });

example:-
let promise = new Promise(function (resolve, reject) {
    reject('Promise Rejected')
})
 
promise
    .then(function (successMessage) {
        console.log(successMessage);
    }, function (errorMessage) {
        //error handler function is invoked
        console.log(errorMessage);
    });
	
2. Promise catch() Method: It is invoked when a promise is either rejected or some error has occurred in execution. It is used as an Error Handler whenever at any step there is a chance of getting an error.

Parameters: It takes one function as a parameter.

Function to handle errors or promise rejections.(.catch() method internally calls .then(null, errorHandler), i.e. .catch() is just a shorthand for .then(null, errorHandler) )
Syntax:

.catch(function(error){
        //handle error
    })
	
example:-
let promise = new Promise(function (resolve, reject) {
    reject('Promise Rejected')
})
 
promise
    .then(function (successMessage) {
        console.log(successMessage);
    })
    .catch(function (errorMessage) {
        //error handler function is invoked
        console.log(errorMessage);
    });

Microtask queue --> Promise ka result microtask queue mai jata h na ki callback queue. microtask queue ki priority jyada h callback queue.

Promise.resolve:- it always returns promise.
const myPromise = Promise.resolve(5);
   myPromise.then(value=>{
   console.log(value);
 })


Promise chaining
Note:- Promise m then humesa promise return krta hai. agar then method se kuch return nhi krte h to ye 'undefined'(Promise.resolve(undefined)) return krta hai.


function myPromise(){
  return new Promise((resolve, reject)=>{
    resolve("foo");
  })
}

myPromise()
  .then((value)=>{
    console.log(value);
    value += "bar";
    return value // internally Promise.resolve(value)
  })
  .then((value) =>{
    console.log(value);
    value += "baaz";
    return value;
  })
  .then(value=>{
    console.log(value);
  })


AJAX- Asynchronous javascript and XML

we have 3 most common ways to create and send request to server:-
	1. xmlHTTPRequest (old way of doing)
	2. fetch API (new way of doing)
	3. axios (3rd party library)
	
	
1. xmlHTTPRequest
const URL = "https://jsonplaceholder.typicode.com/posts";
const xhr = new XMLHttpRequest();
// console.log(xhr);
// step1
// console.log(xhr.readyState);
xhr.open("GET",URL);
// console.log(xhr.readyState);
// xhr.onreadystatechange = function(){
//     // console.log(xhr.readyState);
//     if(xhr.readyState === 4){
//         console.log(xhr)
//         const response = xhr.response;
//         const data = JSON.parse(response);
//         console.log(typeof data);
//     }
// }

xhr.onload = function(){ //isme hume readyState ko check krne ki jarurat nhi h kyuki onload tabhi run krta h jab readyState ki value 4 ho.
    if(xhr.status >= 200 && xhr.status < 300) {  // error handling
		const response = xhr.response;
		const data = JSON.parse(response);
		console.log(data);
	} else {
		console.log("Something went wrong");
	}	
}

xhr.onerror = () => {
	console.log("network error");
}

xhr.send();

readyState value and their meaning:-
Value	State				Description
0		UNSENT				Client has been created. open() not called yet.
1		OPENED				open() has been called.
2		HEADERS_RECEIVED	send() has been called, and headers and status are available.
3		LOADING				Downloading; responseText holds partial data.
4		DONE				The operation is complete.
 

XHR using promises:-
const URL = "https://jsonplaceholder.typicode.com/posts";

function sendRequest(method, url) {
    return new Promise(function(resolve, reject) {
        const xhr  = new XMLHttpRequest();
        xhr.open(method, url);
        xhr.onload = function() {
            if(xhr.status >= 200 && xhr.status < 300){
                resolve(xhr.response);
            }
            else{
                reject(new Error("Something Went wrong"));
            }
        }

        xhr.onerror = function() {
            reject(new Error("Something went wrong"));
        }

        xhr.send();
    })
}

sendRequest("GET", URL)
    .then(response => {
        const data = JSON.parse(response);
        // console.log(data)
        return data;
    })
    .then(data=>{
        const id = data[3].id;
        return id;
    })
    .then(id=>{
        const url = `${URL}/${id}ssss`;
        return sendRequest("GET", url);
    })
    .then(newResponse => {
        const newData = JSON.parse(newResponse);
        console.log(newData);
    })
    .catch(error =>{
        console.log(error);
    })
	
Fetch API:-- Note:-- Fetch API m catch block sirf network issue pe chalta normally. catch block ko rest issues k liye run krne k liye response.ok ka use krna padega.

// fetch 

const URL = "https://jsonplaceholder.typicode.com/postssss";

fetch(URL,{
    method: 'POST',
    body: JSON.stringify({
        title: 'foo',
        body: 'bar',
        userId: 1,
    }),
    headers: {
        'Content-type': 'application/json; charset=UTF-8',
    },
    })
    .then(response =>{
        if(response.ok){
            return response.json()
        }else{
            throw new Error("Something went wrong!!!")
        }
    })
    .then(data =>{
        console.log(data);
    })
    .catch(error =>{
        console.log("inside catch");
        console.log(error);
    })

Async-Await:-
async makes a function return a Promise.
await makes a function wait for a Promise.
The await keyword can only be used inside an async function.
The await keyword makes the function pause the execution and wait for a resolved promise before it continues:

console.log("1");
const show = async () => {
    console.log("show");
    return "hi";
}
show().then(data => console.log(data));
console.log("2");

O/p:-
1
show
2
hi


// async await

// fetch(URL)
//     .then(response => {
//         return response.json()
//     })
//     .then(data => {
//         console.log(data);
//     })
console.log("script start");
const URL = "https://jsonplaceholder.typicode.com/posts";

// async function getPosts(){
//     const response = await fetch(URL);
//     if(!response.ok){
//         throw new Error("Something went wrong")
//     }
//     const data = await response.json();
//     return data;
// }


const getPosts = async() =>{
    const response = await fetch(URL);
    if(!response.ok){
        throw new Error("Something went wrong")
    }
    const data = await response.json();
    return data;
}

// const myData = getPosts();
// console.log(myData);

getPosts()
    .then((myData) => {
        console.log(myData);
    })
    .catch(error =>{
        console.log("inside catch")
        console.log(error);
    })

console.log("script end ");	

ES6 Modules:--
<head>
<script src="./app.js" type="module"></script> // type="module" krne par defer likhne ki jarurat nhi hoti hai.
</head>

Note:-- try to use "input" event instead of "keyup" || "keypress" || "Keydown"

Decorator Function:- it takes a function as a argument and return that function with inhanced feature.

Debouncing:-- calling a function with some delay. e.g. input box m har ek keyword p function ko call na krk kuch delay pe call krte h jisse performance improve hota hai.
			Debouncing is a programming pattern or a technique to restrict the calling of a time-consuming function frequently, by delaying the execution of the function until a specified time to avoid unnecessary CPU cycles, and API calls and improve performance.
			
const myInput = document.getElementById("input-event");

function findSuggestions(e) {
	console.log("Suggestions for ", e.target.value);
}

function trailingDebouncing(func, delay) { // wait krne k baad function call krna ho tab
	let timeOutId;
	return function(...arg) {
		if(timeOutId) {
			clearTimeout(timeOutId);
		}
		timeOutId = setTimeout(() => {
			func.call(this, ...arg);
		}, delay);
	}
}

function leadingDebouncing(func, delay) { // function call krk wait krna ho tab
	let timeOutId = null;
	return function(...arg) {
		if(timeOutId === null) {
			func.call(this, ...arg);
		}
		clearTimeout(timeOutId);
		timeOutId = setTimeout(() => {
			timeOutId = null;
		}, delay);
	}
}

function debounce(func, delay, option = {leading: false, trailing: true}) { 
	let timeOutId = null;
	return function(...arg) {
		let isInvoked = false;
		if(timeOutId === null && option.leading) {
			func.call(this, ...arg);
			isInvoked = true;
		}
		clearTimeout(timeOutId);
		timeOutId = setTimeout(() => {
			if(option.trailing && !isInvoked) {
				func.call(this, ...arg);
			}
			timeOutId = null;
		}, delay);
	}
}

function clickMe() {
	console.log("Add to cart");
}

btn.addEventListener("click", debounce(clickMe, 300, (option = {leading: false, trailing: true}) ))

const decoratedFindSuggestions = leadingDebouncing(findSuggestions, 300);

myInput.addEventListener("input", decoratedFindSuggestions);

--------------------------
coder dost - JS
-------------------------------------------------------
IIFE - Immediately Invoked Function Expression

(function(name) {
	console.log(`Welcome! ${name}`);
})("Goku");

function is made as expression using () - so function doesn't require name.

Note(tricky):- we can't use continue keyword in forEach loop.
[1, 2, 3, 4, 5].forEach(v => {
  if (v % 2 !== 0) {
    // SyntaxError: Illegal continue statement: no surrounding iteration statement
    continue;
  }
});

Solution:-
// Prints "2, 4"
[1, 2, 3, 4, 5].forEach(v => {
  if (v % 2 !== 0) {
    return;
  }
  console.log(v);
});


Math Library
-----------------------
1.Math.abs(-2) --> 2
2.Math.round(2.66) --> 3 || Math.round(2.46) --> 2
3.Math.floor(2.66) --> 2
4.Math.ceil(2.46) --> 3
5.Math.pow(2,3) --> 8 || 2**3 -->8
6.Math.sqrt(4) --> 2
7.Math.max(2,3,100,46) --> 100
8.Math.min(2,1,100,46) --> 1
9.Math.random() --> 0.4652186276
10.Math.trunc(2.346) --> 2 || Math.trunc(-99.9) --> -99


form m form ko select karke form.typeofInput.value(form.password.value) aise bhi value get kr sakte h ya fir form.valueOfNameAttribute.value(form.username.value) aise bhi value get kar skate hai.

Array Methods
array.slice(startIndex, lastIndex(excluded, optional))
array.at(Index) // useful in the case of negative value it select from the end array.at(-1) provide last element of array.
array.findIndex(cb) --> index of first element which satisfied the condition otherwise -1. 
array.flat(depth level (default 1)) --> convert nested array of arrays into plain array and no effect on original array.
array.flatMap(cb) 
const arr1 = [1, 2, 1];
const result = arr1.flatMap((num) => (num === 2 ? [2, 2] : 1));
console.log(result);
// Expected output: Array [1, 2, 2, 1] 


Date & Time (Methods):--
-----------------------
let completeDateAndTime = new Date();
console.log(completeDateAndTime);

// Get Full Year
console.log(completeDateAndTime.getFullYear());

// Get Month
console.log(completeDateAndTime.getMonth()); // 0 to 11

// Get Month Day
console.log(completeDateAndTime.getDate());

// Get Weekday
console.log(completeDateAndTime.getDay()); // 0 to 6 (0 - sunday, 1 - monday, and so on)

// Get Hours
console.log(completeDateAndTime.getHours());

// Get Minutes
console.log(completeDateAndTime.getMinutes());

// Get Seconds
console.log(completeDateAndTime.getSeconds()); 	

// Get the number of milliseconds since January 1, 1970 00:00:00.
console.log(completeDateAndTime.getTime()); 	



Local Storage:--- It is a API of Browser(Window Object) to store data locally. Every origin separately stores data.
-------------------------
localStorage.setItem(key, value); // Adding Data; key, value --> only string type
localStorage.getItem(key) // Getting Data; key --> only string type; if key is not found, returns null
localStorage.removeItem(key) // Removing data; key --> only string type; 
localStorage.clear() // Clear All Data; removes all keys for that origin

Example:--
let vehicles = [
	{company: "Honda", model: "2009"},
	{company: "Toyota", model: "2010"}
];

let stringOfVehicles = JSON.stringify(vehicles);

//Setting value in local storage
localStorage.setItem('vehicles', stringOfVehicles);

console.log(localStorage);

//Get stored item again in object format
let storedData = localStorage.getItem('vehicles');

let objectFormate = JSON.parse(storedData);

console.log(objectFormate);


Note:-- Constructor function k liye arrow function ka use nhi kar sakte h kyuki new keyword kaam nhi krta h. It will show typeError.

instanceof:-- The instanceof operator tests to see if the prototype property of a constructor appears anywhere in the prototype chain of an object. The return value is a boolean value.

function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
const auto = new Car('Honda', 'Accord', 1998);

console.log(auto instanceof Car);
// Expected output: true

console.log(auto instanceof Object);
// Expected output: true

Note:--
1. Classes are not hoisted.
2. Classes are also first class citizens(Pass as an argument or return).
3. Classes are executed in strict mode.

Prototypal inheritance(using constructor function) -- check

Note:-- For chaining method in class we should return this from the methods.

Short circuiting:-->
let result = "Goku" && "Gohan"; 
console.log(result); // Gohan

let result = 0 && "Gohan"; 
console.log(result); // 0

let result = "Goku" || "Gohan"; 
console.log(result); // Goku

Nullish Coalesing operator(??):--> It return first non-nullish value. For nullish coalesing operator only "null" and "undefined" are falsy value.

let numGuests = 0;
let result = numGuests || 10;
console.log(result); // 10
let result2 = numGuests ?? 10;
console.log(result2); // 0

Object literals shorthand:-->
let menuType = "platinumMenu";
let hotel = {
	name: 'R.K. Guest House',
	location, // incase key and value are same.
	[menuType]: .... // incase we want computed key value.
}

Object Methods:-->
Object.keys(obj) --> return array of keys of provided object.
Object.values(obj) --> return array of values of provided object.
Object.entries(obj) --> return array of arrays([key,value]) of provided object.

Top level "await":-- Before ES2022 we can use await only inside async function But in ES2022 introduced top level "await". It means now we can use "await" outside the async function.
Note:-- Top level await "block the execution" of next code part.

example:--
console.log("Start");
let response = await fetch("https://jsonplaceholder.typicode.com/posts");
let data = await response.json();
console.log(data);
console.log("End");

o/p:-
Start
[data] // wait for data
End

Global Object:--The global Object is the variable window in case of browser. This helps you to use variables across the scopes. Also, it is the this value for global functions
	In non-browser environment, window doesn't exist. but other global objects exist.
	var affects this global obejct, also function declarations.(variable declared with var keyword and function declaration are accessable through window object.)

NOTE : so whenever you have a function which wants to preserve a value over many calls - it's a time for closure.


Currying:--

function sum(a){
  return function(b){
    return function(c){
       console.log(a,b,c)
       return a+b+c
    }
  }
}

let add = a => b => c => a+b+c

let log = time => type => msg => `At ${time.toLocaleString()}: severity ${type} => ${msg}`;

log(new Date())('error')('power not sufficient')

let logNow = log(new Date())

logNow('warning')('temp high')

let logErrorNow = log(new Date())('error')

logErrorNow('unknown error')

Copying objects:--

Shallow Copy:--Many methods can be used to copy object without old reference

1.Object.assign()
let person =  {name:'john'}
let newPerson = Object.assign({}, person) 

2.Spread Operator[...]
let person =  {name:'john'}
let newPerson = {...person} 

But problem with these is they just create a copy of properties of that object , but not creating a copy of their references also.

let addressObject = { city: 'delhi', state: 'delhi' }

let person = {
  name: 'John',
  address: addressObject
};


let newPerson = Object.assign({}, person)
person === newPerson;  // false
person.address === newPerson.address // true

Deep Copy:--This is a hard problem to solve in past as there can be multiple level of nested objects and there can be references to functions etc also. few methods which are there:

1. JSON.stringify and JSON.parse : this method utilizes the fact that every JSON can be converted to a string value (exception of methods/functions)
let addressObject = { city: 'delhi', state: 'delhi' }

let person = {
  name: 'John',
  address: addressObject
};

let str = JSON.stringify(person)
let jsonObject = JSON.parse(str);


2. structuredClone : Browser API which work even for circular references (but functions not supported)
let addressObject = { city: 'delhi', state: 'delhi' }

let person = {
  name: 'John',
  address: addressObject,
};

person.me = person

let newPerson = structuredClone(person);

Symbol:-
	*Symbol is used for making hidden (library used properties).
	*Symbol are always unique - so there is no chance of collision. Even with same "descriptor" they will be uniquely initialized.
	*You can get Symbol for some descriptor or key using some methods.
	*for..in loop ignore Symbols. Also methods like Object.keys() ignore these properties.
	
const id = Symbol("id"); // "id" is descriptor

let person =  {
  name:'john',
  [id]:1
} 

person[id] // 1

Decorator (Wrappers):--It's a design pattern in which you modify the functionality of a function by covering it inside a wrapper.

let modifiedFx = Decorator(preDefinedFx)

Memoization (Caching):- jab kisi function ki return value ko cache krte h to usko memoization kahte h.

function heavy(x) {
  console.log(x + ':heavy');
  return x + ':heavy';
}

function memoized(fx) {
  let map = new Map();
  
  return function (x) {  // wrapper
    if (map.has(x)) {
      return map.get(x);
    } else {
      let memoValue = fx(x);
      map.set(x, memoValue);
      return memoValue;
    }
  };
}

let memoizedHeavy = memoized(heavy)
memoizedHeavy(2);
memoizedHeavy(2); // take from cache


Another Problem

if you try to use this on a method of object, this approach can fail
let task = {
  name: 'demo',
  heavy(x) {
    console.log(x + ':heavy:' + this.name);
    return x + ':heavy' + this.name;
  },
};

function memoized(fx) {
  let map = new Map();
  return function (x) {
    if (map.has(x)) {
      return map.get(x);
    } else {
      let memoValue = fx(x);
      map.set(x, memoValue);
      return memoValue;
    }
  };
}
task.memoizedHeavy = memoized(task.heavy) 
task.memoizedHeavy(1) // 1:heavyundefined

Solution : use function.call()

Solution

let task = {
  name: 'demo',
  heavy(x) {
    console.log(x + ':heavy:' + this.name);
    return x + ':heavy' + this.name;
  },
};

function memoized(fx) {
  let map = new Map();
  return function (x) {
    if (map.has(x)) {
      return map.get(x);
    } else {
      let memoValue = fx.call(this,x); // this will take obj reference from that object on which it is called.
      map.set(x, memoValue);
      return memoValue;
    }
  };
}
task.memoizedHeavy = memoized(task.heavy) 
task.memoizedHeavy(1) // 1:heavydemo

Debounce:--
Run a function only when - if it has not been called again for a fixed period
Suppose you are typing and take a pause of 1 second. Only then that function should be called.

Note:-- setTimeout(functionRef, delay, param1, param2, /* …, */ paramN)

let count = 1;
function showCount() {
  count++;
  console.log({ count });
}

function debounce(fx, time) {
  let id = null;
  return function (x) {
    if (id) {
      clearTimeout(id);
    }
    console.log({ id });
    id = setTimeout(() => {
      fx(x);
      id = null;
    }, time);
  };
}

let showCountD = debounce(showCount, 2000);
setTimeout(showCountD, 1000);
setTimeout(showCountD, 1500);
setTimeout(showCountD, 2000);
setTimeout(showCountD, 2500);
setTimeout(showCountD, 5000);

Throttle:--
when you have to only allow 1 execution of a function within a period of time
for example you are scrolling fast but only 1 scroll per 100 millisecond is considered.

let count = 1;
function showCount(x) {
  count++;
  console.log({ count, x });
}

function throttle(fx, time) {
  let id = null;
  let arg = [];
  return function (x) {
    arg[0] = x;
    if (!id) {
      id = setTimeout(() => {
        fx(arg[0]);
        id = null;
      }, time);
    }
    console.log({ id });
  };
}

let showCountT = throttle(showCount, 2000);
setTimeout(showCountT, 1000, 1);
setTimeout(showCountT, 1500, 2);
setTimeout(showCountT, 2000, 3);
setTimeout(showCountT, 2500, 4);
setTimeout(showCountT, 3100, 5);
setTimeout(showCountT, 4500, 6);
setTimeout(showCountT, 5000, 7);

o/p:- 
{count: 2, x: 4}
{count: 3, x: 6}
{count: 4, x: 7}


Iterables and Iterators:--

Iterable (protocol):--Iterables are objects in which we can make array like iteration (Example using for..of loop of spread operators)

	Array are iterables
	String are iterables
To make any object iterable we have these conditions
	
	implement a Symbol.iterator property, which should be a function which return an Iterator Object

	iterable[Symbol.iterator]() => Iterator

Iterator (protocol)
Iterators are objects which have :

	*a next() method which return a object which is of format {value:-some-value-, done:-boolean-} e.g. *{value: 1, done: false}
	*value is the value we are interested in, while done tells us when to stop. Generally when done:true the value:undefined
Now, making an Iterable is like this:

let iterator = {
  i: 0,
  next: function () {
    return { value: this.i, done: this.i++ > 5 };
  },
};

let iterable = {
  name: 'john',
  age: 34,
  [Symbol.iterator]() {
    return iterator;
  },
};


Example - Range :

let range = {
  start: 0,
  end: 5,
  [Symbol.iterator]() {
    let that = this; // this line is very important
    let i = this.start;
    return { // iterator object
      next: function () {
        return { value: i, done: i++ > that.end };
      }
    };
  },
};

Array

let num = [1, 2, 3];
let iterator = num[Symbol.iterator]();
iterator.next();
iterator.next();
iterator.next();
iterator.next();


Infinite iterators:--
*As we can see that we can control, how to control the next() function. In few cases, it will be useful to have iterators which can need to generate the next value infinitely
*If you use such iterators in a loop etc. it can be dangerous as can create infinite loop. But can be controlled by break etc.
*we will cover all this in generators.

Iterables vs Array-like:--
	*Iterable objects are based on Symbol.iterator method as defined above
	*Array-like objects are based on array protocols (index and length)

An object can be
	Iterable + Array-like
	Iterable only
	Array-like only
	None of them (not Iterable nor Array-like )
	
Conversions:--
Array-like to Array
Array.from() : method is used for this
let arrayLike = {
  0: 0,
  1: 5,
  length: 2
};

let arr = Array.from(arrayLike);

// also used for general things

let set = new Set()
set.add(1);
set.add(2);
let arr2 = Array.from(set) // [1,2]

Map:--
	*this data type is also iterable
	*special this is can have keys also as numbers, booleans, objects
	*also map maintains the order of keys added.
	
Converting Object to Map:--
We can use Object.entries() method for this.
let obj = {a:1,b:2,c:3};
let map = new Map(Object.entries(obj));

Converting Map to Object:--
We can use Object.fromEntries() method for this.
let map = new Map();
map.set('a', 1);
map.set('b', 2);
map.set('c', 3);

let obj = (Object.fromEntries(map.entries())); // {a:1,b:2,c:3}

Set:--
Set is another iterable
Set only contains uniques elements

WeakMap and Weakset:--
These are 2 alternative way of creating Map or Set like data types - when only object keys are considered.
They have very limited operations and doesn't support all functionality
Main purpose is that when keys are marked as null they are garbage collected. So this helps in better memory management
let weakMap = new WeakMap()
let person = {name:'john'}

weakMap.set(person, {....});

person = null // in future we decide to remove this key

// so weakMap will remove it from memory space automatically

Generators:-- read from doc.

Note:-- enumerable--> jo countable ho.

NOTE : Shims are piece of code to correct some existing behaviour, while Polyfills are new API/ behaviours.

Private and Protected properties:--
in Object Oriented Programming there is a concept of Encapsulation or Data Hiding - so that you just interact with object via given methods/properties. This avoids changing some internal properties which are not meant for public use.

Protected:--
	*this is something not provided by javascript but by convention and get/set method we can create it
	*you have to use convention of _ in front of property name - making is known to developer that this property is not directly accessible and used only via get/set accessors.
	
Private:--
	*this is a new feature and is not very frequently used.
	*you can name any proptery with #
	
Promise finally() method:-- The finally() method is always executed whether the promise is fulfilled or rejected. In other words, the finally() method is executed when the promise is settled.

promise
    .then(result => {
        // process the result
    })
    .catch(error => {
        // handle the error
    })
    .finally(() => {
        // clean up the resources
    });
	
Promise API:--
Promise.all:--Parallel execution of async functions - only work when all promises are fullfiled

Promise.all([
    asyncFx(1,2),
    asyncFx(2,3),
    asyncFx(5,6)
]).then(results=>{
    console.log(results) // array of resolved value, same order
})

Promise.allSettled:--Parallel execution of async functions - only work when all promises are fullfiled or rejected

Promise.allSettled([
    asyncFx(1,2),
    asyncFx(2,3),
    asyncFx(5,6)
]).then(results=>{
    console.log(results) // array of resolved/reject objects, same order
})

Promise.race:--Parallel execution of async functions - works when any one of promises are fullfiled or rejected

Promise.race([
    asyncFx(1,2),
    asyncFx(2,3),
    asyncFx(5,6)
]).then(results=>{
    console.log(results) // value of first settled (resolved/rejected) promise
})

Promise.any:--Parallel execution of async functions - works when any one of promises are fullfiled

Promise.any([
    asyncFx(1,2),
    asyncFx(2,3),
    asyncFx(5,6)
]).then(results=>{
    console.log(results) // value of first fullfilled promise
})

Promise.reject:--created already promise which gets rejected just after creation

let promise = Promise.reject('error');


Promise.resolve:--created already promise which gets resolved just after creation

let promise = Promise.resolve(123);

From Code Improve
-----------------
console.time('checkTime');
console.warn('Hello');
console.assert(1>2, 'noooo');
console.error('msg ID');
var data = { name: 'Goku', empId: 'CS032'};
console.table(data)
console.timeEnd('checkTime');

Error handling:--(try, catch, throw, finally)
try {
	let x = 11;
	if(x == 10) throw "Not Valid";
	console.log(x);
}catch(err) {
	console.log('catch called:--', err);
}

finally {
	console.log('Whatever happend, I will called');
}

JavaScript debugging:-
conditional debugging, watch

Note:--Event propogation-->

	event.stopPropagation(); // yha se aage propogation nhi hoga.
	event.stopImmediatePropagation(); // same element p same event k liye baki listners stop ho jayenge.
	
Race vs any in promise:- race m jo promise jaldi s resolve ya reject hota h wo promise show krta h jabki any m jo bhi promise jaldi s sirf resolve(fulfilled) hoga to us promise ka result show krega aur ager sabhi reject ho jayenge us case m reject ka error show krega.

Pure Function:-- copy s padhna h.

BOM(Browser Object Modal):-- 
	1. Navigator
	2. History
	3. Location
	4. Screen
	
Tech Gun
------------
prompt('msg', defaultValue) // show a message, input text. it returns the text on ok or,if cancel button or Esc is clicked, null.
confirm('msg') // for confirmation , return true or false

Removing Event Listener--
element.removeEventListener('event', listner);

tech gun
yahoo baba
code improve
coder dost 
harshit vashist